---
import { database } from "../shared/db.mjs"
import GamePreview from "./GamePreview.astro"
import { ObjectId } from "mongodb"
const cursor = Astro.props.cursor
const doPagination = Astro.props.pagination ?? false
const gamesPerPage = Astro.props.games ?? 5
const onlyCompleted = Astro.props.onlyCompleted ?? false
let nextCursor = null
let prevCursor = null
let cursorObjectId = null
if (cursor) cursorObjectId = ObjectId.createFromHexString(cursor)
const games = await database.getGames(cursorObjectId, gamesPerPage, onlyCompleted)
if (doPagination && games.length == gamesPerPage) {
	nextCursor = games[games.length - 2][0]._id
	games.pop()
}
// Check if there's a previous page by looking for one item before the current cursor
if (doPagination && cursor && games.length > 0) {
	const firstItemId = games[0][0]._id
	// Query for items with _id > firstItemId (going backwards in time) to check if previous page exists
	const findDocument = { depth: 0 }
	if (onlyCompleted) findDocument.depth = 15
	findDocument._id = { $gt: firstItemId }
	const previousCheck = await database.gameCollection.find(findDocument).sort({ _id: 1 }).limit(1).toArray()
	if (previousCheck.length > 0) {
		// If there are items after the first item (earlier in time), we can go back
		// The previous page cursor should be the ID that's approximately one page back
		// We fetch items going backwards to find the right cursor
		const prevPageItems = await database.gameCollection.find(findDocument).sort({ _id: 1 }).limit(gamesPerPage).toArray()
		if (prevPageItems.length > 0) {
			prevCursor = prevPageItems[prevPageItems.length - 1]._id
		}
	}
}
---

<div class="flex-container">
	{
		games.map((game: any) => {
			return <GamePreview game={game} />
		})
	}
</div>
<div class="flex-container">
	{
		prevCursor && (
			<a href={`/games/${prevCursor}`} class="pagination-button">
				Previous Page
			</a>
		)
	}
	{
		nextCursor && (
			<a href={`/games/${nextCursor}`} class="pagination-button">
				Next Page
			</a>
		)
	}
</div>
